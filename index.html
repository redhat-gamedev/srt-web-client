<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@5.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@6.10.2/dist/protobuf.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
<!--    <script src="https://cdn.jsdelivr.net/npm/util@0.12.3/util.min.js"></script>-->
<!--    <script src="https://cdn.jsdelivr.net/npm/minimist@1.2.5/index.min.js"></script>-->
    <script src="javascript/rhea.js"></script>
<!--    <script src="javascript/options.js"></script>-->
</head>
<body>

  <script>
    // used to tell the server where to send event messages
    const myuuid = uuidv4();
    //const myuuid="thoraxe"

    // our unique player id for sending our commands
    var player_uuid = "";

    const force_multiplier = 200;

    // the broker endpoint
    const broker_endpoint="ws://192.168.2.221:5672"

    const players = {};

    // protobuf stuff
    var CommandBuffer;
    var SecurityCommandBuffer;
    var GameEventBuffer;
    var EntityGameEventBuffer;
    var RawInputCommandBuffer;

    // phaser stuff
    const resolution_width = 800;
    const resolution_height = 600;
    var config = {
      type: Phaser.AUTO,
      width: resolution_width,
      height: resolution_height,
      physics: {
          default: 'arcade',
          arcade: {
              debug: true
          }
        },
      scene: {
        create: create,
        preload: preload,
        update: update
      }
    };

    var graphics;
    var player_group;
    var cursors;

    var game = new Phaser.Game(config);


    function create () {
      player_group = this.physics.add.group({
          collideWorldBounds: true
      });
      cursors = this.input.keyboard.createCursorKeys();
    }

    function preload () {
      //this.load.setBaseURL('http://labs.phaser.io');

      this.load.image('spacepod', 'images/spacepod.png');
    }

    function update() {
      // iterate over the players and draw their last known location
      Object.values(players).forEach (player=>{

        // don't do anything if we don't have a body object for the player yet
        if (player.body != null) {
          // if the player has no phaser group object, create one
          if (player.stuff.phaser_group == null) {
            const xpos = player.body.position.x + (resolution_width/2);
            const ypos = player.body.position.y + (resolution_height/2);
            player.stuff.phaser_group = player_group.create(xpos, ypos, 'spacepod');
          } else {
            // otherwise just update the group's position
            player.stuff.phaser_group.x = player.body.position.x + (resolution_width/2);
            player.stuff.phaser_group.y = player.body.position.y + (resolution_height/2);
          };
        }
        //console.log(player);
      });

      var xmove = 0;
      var ymove = 0;

      // grab keyboard input to move our player
      if (cursors.left.isDown) {
        xmove = -1 * force_multiplier;
      }
      else if (cursors.right.isDown) {
        xmove = 1 * force_multiplier;
      };

      if (cursors.up.isDown) {
        ymove = 1 * force_multiplier;
      }
      else if (cursors.down.isDown) {
        ymove = 1 * force_multiplier;
      }

      // handle keyboard stuff
      if ((xmove != 0) || (ymove != 0)) {
        const keyboard_input = {
          type: 2,
          rawInputCommandBuffer: {
            type: 1,
            UUID: player_uuid,
            dualStickRawInputCommandBuffer: {
              pbv2Move: {
                x: xmove, y: ymove
              },
              pbv2Shoot: {
                x: 0, y: 0
              }
            }
          }
        };
        const keyboard_message = CommandBuffer.create(keyboard_input);
        const keyboard_buffer = CommandBuffer.encode(keyboard_message).finish();

        // STOMP stuff
        // client.publish({
        //   destination: 'COMMAND.IN',
        //   binaryBody: keyboard_buffer,
        //   headers: {
        //     'content-type': 'application/octet-stream',
        //     'reply-to': 'COMMAND.OUT.' + myuuid
        //   }
        // });
      }

    };

    // AMQP messaging stuff
    var client = require("rhea");
    var ws = client.websocket_connect(WebSocket);
    var connection = client.connect({"connection_details":ws(broker_endpoint, ["binary", "AMQPWSB10", "amqpws"]), "reconnect":false});
    var receiver = connection.open_receiver("GAME.EVENT.OUT");
    var sender = connection.open_sender("COMMAND.IN");

    // STOMP stuff
    // var client;
    //
    (async function() {
    //
    //   client = new StompJs.Client({
    //     brokerURL: 'ws://' + broker_endpoint + ':61613',
    //     connectHeaders: {
    //       login: 'user',
    //       passcode: 'password',
    //     },
    //     debug: function (str) {
    //       //console.log(str);
    //     },
    //     reconnectDelay: 5000,
    //     heartbeatIncoming: 4000,
    //     heartbeatOutgoing: 4000,
    //   });
    //
    //   client.onConnect = function (frame) {
    //     // Do something, all subscribes must be done is this callback
    //     // This is needed because this will be executed after a (re)connect
    //   };
    //
    //   client.onStompError = function (frame) {
    //     // Will be invoked in case of error encountered at Broker
    //     // Bad login/passcode typically will cause an error
    //     // Complaint brokers will set `message` header with a brief message. Body may contain details.
    //     // Compliant brokers will terminate the connection after any error
    //     console.log('Broker reported error: ' + frame.headers['message']);
    //     console.log('Additional details: ' + frame.body);
    //   };
    //
    //   client.activate();

        client.on('connection_open', function (context) {
            console.log("AMQP connection open to " + broker_endpoint)
        });

        client.on('receiver_open', function (context) {
            console.log("receiver_open");
        });

        client.on('sender_open', function (context) {
            console.log("sender_open");
        });

        // // i.e. received a message
        // client.on('message', function (context) {
        //     console.log('received ' + context.message.body);
        // });

        // i.e. we have credit to do a send
        client.on('sendable', function (context) {
            console.log('sendable');
        });

        client.on('disconnected', function (context) {
            console.log('disconnected');
        });

        try {
          const loadCommandBuffer = await protobuf.load("../proto/CommandBuffer.proto");
          CommandBuffer = loadCommandBuffer.lookupType("redhatgamedev.srt.CommandBuffer");

          const loadSecurityCommandBuffer = await protobuf.load("../proto/SecurityCommandBuffer.proto");
          SecurityCommandBuffer = loadSecurityCommandBuffer.lookupType("redhatgamedev.srt.SecurityCommandBuffer");

          const loadGameEventBuffer = await protobuf.load("../proto/GameEventBuffer.proto");
          GameEventBuffer = loadGameEventBuffer.lookupType("redhatgamedev.srt.GameEventBuffer");

          const loadEntityGameEventBuffer = await protobuf.load("../proto/EntityGameEventBuffer.proto");
          EntityGameEventBuffer = loadEntityGameEventBuffer.lookupType("redhatgamedev.srt.EntityGameEventBuffer");

          const loadRawInputCommandBuffer = await protobuf.load("../proto/RawInputCommandBuffer.proto");
          RawInputCommandBuffer = loadRawInputCommandBuffer.lookupType("redhatgamedev.srt.RawInputCommandBuffer");

          //console.log('loaded', {CommandBuffer, EntityGameEventBuffer});

          // there can be only one -- join, that is
          const scb_join = {type: 1, securityCommandBuffer: {type: 1, UUID: myuuid}};
          const scb_join_message = CommandBuffer.create(scb_join);
          const scb_join_buffer = CommandBuffer.encode(scb_join_message).finish();
          // setting content-type header is not mandatory, however a good practice

          // STOMP stuff
          // client.publish({
          //     destination: 'COMMAND.IN',
          //     binaryBody: scb_join_buffer,
          //     headers: {
          //         'content-type': 'application/octet-stream',
          //         'reply-to': 'COMMAND.OUT.' + myuuid
          //     },
          // });

            // AMQP stuff
            // TODO: This is likely wrong as we're dumping in the protobuf when we should be dumping in a message
            // containing a protobuf as the data section

            var amqp_message = client.message;
            var body = amqp_message.data_section(scb_join_buffer);
            // sender.send({message_id:sent, body});
            sender.send({body});

          player_initialize = function (UUID) {
            players[UUID] = { body: null, stuff: {}};
          }

          process_security_game_event = function (buffer) {
            switch(buffer.type) {
              case 1:
                console.log('a player joined: ' + buffer.joinSecurityGameEventBuffer.UUID);
                // a security game event with a type of 1 is a player join
                // create an entity in the player array with the incoming uuid
                player_initialize(buffer.joinSecurityGameEventBuffer.UUID);
                break;
            }
          };

          process_entity_game_event = function (buffer) {
            if (players[buffer.UUID] == null) {
              console.log('found a player we don\'t know about');
              player_initialize(buffer.UUID);
            };
            // just store the pbbody details for the player
            players[buffer.UUID].body = buffer.body;
          };

          // the function when game event messages are received
          game_event_message_callback = function (message) {
              console.log("game_event_message_callback");
            // called when the client receives a STOMP message from the server
            // if (message.binaryBody) {
              if (message.body) {
                  // console.log("gemc has message.body");
              // we always receive a gameevent
              // const decoded_event_message = GameEventBuffer.decode(message.binaryBody);
                  console.log("gemc message is " + message);
                  // console.log("gemc message.body is " + message.body);
                  // console.log("gemc message.body.contentType is " + message.body.contentType);
                  // console.log("gemc message.body.content is " + message.body.content);
                  // // console.log("gemc message.body Uint8Array is " + Uint8Array(message.body));
                  // var u8a = new Uint8Array(message.body);
                  // console.log("gemc message.body Uint8Array is " + u8a);
                  // console.log("gemc message body typecode " + message.body.typecode);
                  // // console.log("qemc message.body.content.length is " + message.body.content.length);
                  // console.log("qemc message.body.content is " + message.body.content);
                  // console.log("qemc message.content is " + message.content);
                  // console.log("gemc message.body.data is " + message.body.data);
                  // console.log("gemc message.body.data_section is " + message.body.data_section);
                  // console.log("gemc message.binary is " + message.binary);
                  // console.log("qemc message.typecode is " + message.typecode);


                  // var decoded = client.decode(message);
                  // console.log("gemc message decoded is " + decoded);
                  // var binaryBody = message.body.data;
                  // const decoded_event_message = GameEventBuffer.decode(message.body);
                  const decoded_event_message = GameEventBuffer.decode(message.body);
                  // console.log("gemc after decoding message.body - dem is " + decoded_event_message);
              //console.log(decoded_event_message);)

              // check on what type of game event we received
              switch(decoded_event_message.type) {
                case 2:
                  console.log('got a security event');
                  //console.log(decoded_event_message);
                  // security message
                  process_security_game_event(decoded_event_message.securityGameEventBuffer);
                  break;
                case 1:
                    console.log("gemc got an entity game event");
                  // entity game event buffer is about a specific player
                  process_entity_game_event(decoded_event_message.entityGameEventBuffer);
                  break;
                  default:
                      console.log("gemc got a default");
              }
            } else {
              console.log('for some reason we got a message with no binary body');
            }
          };

          // AMQP stuff
            // i.e. received a message
            client.on('message', function (context) {
                console.log('received ' + context.message.body);
                game_event_message_callback(context.message)
            });

            command_message_callback = function(message) {
            console.log('got a command message');
            if (message.binaryBody) {
              // the command message is just our unique player UUID
              player_uuid = new TextDecoder("utf-8").decode(message.binaryBody);
              console.log('unique player uuid: ' + player_uuid);
            }
          };

          // subscribe to the GAME.EVENT.OUT queue
          // STOMP stuff
          // var game_event_subscription = client.subscribe('GAME.EVENT.OUT', game_event_message_callback);
          // var my_command_subscription = client.subscribe('COMMAND.OUT.' + myuuid, command_message_callback);

          } catch (e) {
              console.error('Error during client initialization');
              throw e;
              /* handle error */
          }

      }

    ());
  </script>

</body>
</html>
